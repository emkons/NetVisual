{"version":3,"sources":["webpack:///./src/Graphy/classes/Layout.ts","webpack:///./src/Graphy/layout/KamadaKawai.ts","webpack:///./src/Graphy/layout/ForceAtlas.ts","webpack:///./src/Graphy/layout/FruchtermanReingold.ts","webpack:///./src/Graphy/layout/MDS.ts","webpack:///./src/Graphy/layout/ISOMv2.ts"],"names":["__webpack_require__","d","__webpack_exports__","Layout","_Events__WEBPACK_IMPORTED_MODULE_0__","[object Object]","this","timePerIteration","running","totalRuntime","initRuntime","graph","timeStart","window","performance","now","init","timeEnd","setTimeout","iterate","Promise","resolve","subscribe","startTime","finishTime","process","shouldContinue","dispatch","incremental","console","log","nodes","resetForce","forEach","node","layoutProps","f","x","y","i","initNodeLayoutProps","r","KamadaKawai","_classes_Layout__WEBPACK_IMPORTED_MODULE_0__","_util__WEBPACK_IMPORTED_MODULE_1__","diameter","sprConst","currPass","shouldStop","mDi","mD","edges","maxDeltaNode","delta","innerIters","oldX","oldY","A","B","C","dx","dy","den","Object","k","const","id","l","length","myDx","myDy","deltaY","deltaX","newX","newY","newDxx","newDyy","oldDx","oldDy","oldMiDist","newDx","newDy","newMiDist","maxDeltaNodeDelta","maxDelta","maxDeltaIndex","index","Math","sqrt","dMax","calcPaths","n1","n2","min","dist","max","edgeLen","count","turn","PI","angle","sin","cos","myD1","myD2","miDist","ForceAtlas","inertia","repStr","attrStr","maxDispl","freezeBal","freezeStr","freezeIner","gravity","speed","cooling","outAttrDistr","adjustSizes","minMovement","getDegree","edge","source","target","nx","ny","gf","prevLimit","ratio","freeze","FruchtermanReingold","SPEED_DIVISOR","AREA_MULTIPLICATOR","area","maxDistance","xDist","yDist","force","e","nS","nT","speedMultiplier","limitedDist","MDS","scale","sum","n1M","push","dist2","mean","averages","map","row","reduce","prev","col","j","values","vectors","maxEigen","maxEigenIndex","indexOf","Infinity","max2Eigen","ISOMv2","maxIterations","adaption","radius","iterPerRadius","bounds","t","minRadius","minAdaption","tmp","random","winner","distSqr","queue","visited","pop","currAdaption","pow","nb","factor","exp","ceil","floor","boundsEdgeSize"],"mappings":"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","file":"layout.js","sourcesContent":["import Events from './Events'\r\nimport Graph, { Node } from './Graph'\r\n\r\nexport default abstract class Layout extends Events {\r\n  public abstract readonly incremental: boolean\r\n  protected timePerIteration: number = 3\r\n\r\n  protected running: boolean = false\r\n  protected totalRuntime: number = 0\r\n  protected initRuntime: number = 0\r\n\r\n  public start(graph: Graph): Promise<Graph> {\r\n    const timeStart: number = window.performance.now()\r\n    this.init(graph)\r\n    const timeEnd: number = window.performance.now()\r\n    this.initRuntime = timeEnd - timeStart\r\n    this.totalRuntime = timeEnd - timeStart\r\n    this.running = true\r\n    setTimeout(() => {\r\n      this.iterate(graph)\r\n    }, 0)\r\n    return new Promise<Graph>(resolve => {\r\n      this.subscribe('done', resolve)\r\n    })\r\n  }\r\n\r\n  protected iterate(graph: Graph): void {\r\n    const startTime = window.performance.now()\r\n    let finishTime = 0\r\n    do {\r\n      this.process(graph)\r\n      finishTime = window.performance.now()\r\n    } while (finishTime - startTime < this.timePerIteration && this.shouldContinue(graph))\r\n    this.totalRuntime += finishTime - startTime\r\n\r\n    this.dispatch('iteration', graph)\r\n\r\n    if (this.incremental && this.running && this.shouldContinue(graph)) {\r\n      setTimeout(() => {\r\n        this.iterate(graph)\r\n      }, 0)\r\n    } else {\r\n      console.log(`Layout finished in ${this.totalRuntime}ms, init time: ${this.initRuntime}`)\r\n      this.dispatch('done', graph)\r\n    }\r\n  }\r\n\r\n  public getInitRuntime() {\r\n    return this.initRuntime\r\n  }\r\n\r\n  public getTotalRuntime() {\r\n    return this.totalRuntime\r\n  }\r\n\r\n  public stop() {\r\n    this.running = false\r\n    return this.running\r\n  }\r\n\r\n  protected initNodeLayoutProps(nodes: Node[], resetForce: boolean = true): void {\r\n    nodes.forEach(node => {\r\n      if (!node.layoutProps) {\r\n        node.layoutProps = {\r\n          f: {\r\n            x: 0,\r\n            y: 0,\r\n          },\r\n          i: {\r\n            x: 0,\r\n            y: 0,\r\n          },\r\n        }\r\n      }\r\n      if (resetForce) {\r\n        node.layoutProps.f = {\r\n          x: 0,\r\n          y: 0,\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  protected init(graph: Graph): void {\r\n    this.initNodeLayoutProps(graph.nodes())\r\n  }\r\n\r\n  protected abstract process(graph: Graph): void\r\n\r\n  protected abstract shouldContinue(graph: Graph): boolean\r\n}\r\n","import Layout from '../classes/Layout'\r\nimport { ILayout } from '../classes/ILayout'\r\nimport Graph, { Node } from '../classes/Graph'\r\nimport { sumSqrt } from './util'\r\n\r\nexport default class KamadaKawai extends Layout implements ILayout {\r\n  public incremental = true\r\n\r\n  // Properties\r\n  protected diameter: number = 6000\r\n  protected sprConst: number = 10\r\n\r\n  // Internal variables\r\n  private currPass: number = 2\r\n  private edgeLen: number\r\n\r\n  private shouldStop: boolean = false\r\n\r\n  // deltas\r\n  private mDi: number = 0\r\n  private mD: number = 10\r\n\r\n  protected process(graph: Graph) {\r\n    const nodes = graph.nodes()\r\n    const edges = graph.edges()\r\n\r\n    this.initNodeLayoutProps(nodes)\r\n\r\n    const mDi = this.mDi\r\n    const maxDeltaNode = nodes[mDi]\r\n    // const originalX = maxDeltaNode.x\r\n    // const originalY = maxDeltaNode.y\r\n\r\n    let delta = this.mD\r\n    let innerIters = 0\r\n    while (delta > 0.001 && innerIters < 10) {\r\n      innerIters += 1\r\n      const oldX = maxDeltaNode.x\r\n      const oldY = maxDeltaNode.y\r\n\r\n      // Calculate Dx, Dy, A, B, C\r\n      let A = 0\r\n      let B = 0\r\n      let C = 0\r\n      nodes.forEach(node => {\r\n        if (node === maxDeltaNode) return\r\n        const dx = oldX - node.x\r\n        const dy = oldY - node.y\r\n        const dist = sumSqrt(dx, dy)\r\n        const den = dist * (dx * dx + dy * dy)\r\n        const k = maxDeltaNode.layoutProps.const[node.id]\r\n        const l = maxDeltaNode.layoutProps.length[node.id]\r\n        A += k * (1 - (l * dy * dy) / den)\r\n        B += (k * l * dx * dy) / den\r\n        C += k * (1 - (l * dx * dx) / den)\r\n      })\r\n      const myDx = maxDeltaNode.layoutProps.delta['x']\r\n      const myDy = maxDeltaNode.layoutProps.delta['y']\r\n\r\n      // Solve linear equations\r\n      const deltaY = (myDx * B - myDy * A) / (A * C - B * B)\r\n      const deltaX = (B * myDy - C * myDx) / (A * C - B * B)\r\n\r\n      maxDeltaNode.x = oldX + deltaX\r\n      maxDeltaNode.y = oldY + deltaY\r\n      const newX = oldX + deltaX\r\n      const newY = oldY + deltaY\r\n\r\n      // Update delta values\r\n      let newDxx = 0\r\n      let newDyy = 0\r\n      nodes.forEach(node => {\r\n        if (node === maxDeltaNode) return\r\n        const oldDx = oldX - node.x\r\n        const oldDy = oldY - node.y\r\n        const oldMiDist = sumSqrt(oldDx, oldDy)\r\n        const newDx = newX - node.x\r\n        const newDy = newY - node.y\r\n        const newMiDist = sumSqrt(newDx, newDy)\r\n        const k = maxDeltaNode.layoutProps.const[node.id]\r\n        const l = maxDeltaNode.layoutProps.length[node.id]\r\n        const delta = node.layoutProps.delta\r\n        delta['x'] -= k * (oldDx - (l * oldDx) / oldMiDist)\r\n        delta['y'] -= k * (oldDy - (l * oldDy) / oldMiDist)\r\n        delta['x'] += k * (newDx - (l * newDx) / newMiDist)\r\n        delta['y'] += k * (newDy - (l * newDy) / newMiDist)\r\n        newDxx += k * (newDx - (l * newDx) / newMiDist)\r\n        newDyy += k * (newDy - (l * newDy) / newMiDist)\r\n      })\r\n\r\n      const maxDeltaNodeDelta = maxDeltaNode.layoutProps.delta\r\n      maxDeltaNodeDelta['x'] = newDxx\r\n      maxDeltaNodeDelta['y'] = newDyy\r\n      delta = newDxx * newDxx + newDyy * newDyy\r\n\r\n      maxDeltaNode.x = newX\r\n      maxDeltaNode.y = newY\r\n    }\r\n\r\n    // Calculate deltas\r\n    let maxDelta = 0\r\n    let maxDeltaIndex = 0\r\n    nodes.forEach((node, index) => {\r\n      const myDx = node.layoutProps.delta['x']\r\n      const myDy = node.layoutProps.delta['y']\r\n      const delta = myDx * myDx + myDy * myDy\r\n      if (delta > maxDelta) {\r\n        maxDelta = delta\r\n        maxDeltaIndex = index\r\n      }\r\n    })\r\n    this.mD = maxDelta\r\n    this.mDi = maxDeltaIndex\r\n  }\r\n\r\n  protected init(graph: Graph): void {\r\n    this.initNodeLayoutProps(graph.nodes())\r\n\r\n    this.diameter = Math.sqrt(graph.nodes().length) * 300\r\n    // Initialize dMax\r\n    let dMax = 0\r\n\r\n    // Get node distances and uniformify them\r\n    const nodes = graph.calcPaths()\r\n    nodes.forEach(n1 => {\r\n      nodes.forEach(n2 => {\r\n        if (n1 === n2) return\r\n        const min = Math.min(n1.layoutProps.dist[n2.id], n2.layoutProps.dist[n1.id])\r\n        dMax = Math.max(dMax, min)\r\n        n1.layoutProps.dist[n2.id] = min\r\n        n2.layoutProps.dist[n1.id] = min\r\n      })\r\n    })\r\n    this.edgeLen = this.diameter / dMax\r\n\r\n    // Calculate d, l and k\r\n    nodes.forEach(n1 => {\r\n      n1.layoutProps.length = {}\r\n      n1.layoutProps.const = {}\r\n      nodes.forEach(n2 => {\r\n        if (n1 === n2) return\r\n        if (!n2.layoutProps.length) n2.layoutProps.length = {}\r\n        if (!n2.layoutProps.const) n2.layoutProps.const = {}\r\n        const dist = this.edgeLen * n1.layoutProps.dist[n2.id]\r\n        const k = this.sprConst / (dist * dist)\r\n        n1.layoutProps.length[n2.id] = dist\r\n        n2.layoutProps.length[n1.id] = dist\r\n        n1.layoutProps.const[n2.id] = k\r\n        n2.layoutProps.const[n1.id] = k\r\n      })\r\n    })\r\n\r\n    // Position nodes\r\n    const count = nodes.length\r\n    const turn = (Math.PI * 2) / count\r\n    let angle = 0\r\n\r\n    nodes.forEach(node => {\r\n      node.x = Math.sin(angle) * this.diameter\r\n      node.y = Math.cos(angle) * this.diameter\r\n      angle += turn\r\n    })\r\n\r\n    // Initialize Delta\r\n    let maxDelta = 0\r\n    let maxDeltaIndex = 0\r\n    nodes.forEach((n1, index) => {\r\n      let myD1 = 0\r\n      let myD2 = 0\r\n      nodes.forEach(n2 => {\r\n        if (n1 === n2) return\r\n        const dx = n1.x - n2.x\r\n        const dy = n1.y - n2.y\r\n        const miDist = sumSqrt(dx, dy)\r\n        myD1 += n1.layoutProps.const[n2.id] * (dx - (n1.layoutProps.length[n2.id] * dx) / miDist)\r\n        myD2 += n1.layoutProps.const[n2.id] * (dy - (n1.layoutProps.length[n2.id] * dy) / miDist)\r\n      })\r\n      const delta = myD1 * myD1 + myD2 * myD2\r\n      if (delta <= 0) {\r\n        debugger\r\n      }\r\n      if (delta > maxDelta) {\r\n        maxDelta = delta\r\n        maxDeltaIndex = index\r\n      }\r\n      n1.layoutProps.delta = {\r\n        x: myD1,\r\n        y: myD2,\r\n      }\r\n    })\r\n    this.mD = maxDelta\r\n    this.mDi = maxDeltaIndex\r\n  }\r\n\r\n  protected shouldContinue(graph: Graph): boolean {\r\n    return this.mD > 0.001\r\n  }\r\n}\r\n","import { ILayout } from '../classes/ILayout'\r\nimport Layout from '../classes/Layout'\r\nimport Graph from '../classes/Graph'\r\nimport { forceNodes, sumSqrt, assignForce } from './util'\r\n\r\nexport default class ForceAtlas extends Layout implements ILayout {\r\n  public incremental = true\r\n\r\n  // Properties\r\n  protected inertia: number = 0.1\r\n  protected repStr: number = 200\r\n  protected attrStr: number = 1\r\n  protected maxDispl: number = 100\r\n  protected freezeBal: boolean = true\r\n  protected freezeStr: number = 5\r\n  protected freezeIner: number = 0.1\r\n  protected gravity: number = 1\r\n  protected speed: number = 1\r\n  protected cooling: number = 1\r\n  protected outAttrDistr: boolean = true\r\n  protected adjustSizes: boolean = false\r\n  protected minMovement = 3\r\n\r\n  // Internal variables\r\n  private prevLimit: number\r\n\r\n  protected process(graph: Graph) {\r\n    // const isDynamicWeight: boolean\r\n    const nodes = graph.nodes()\r\n    const edges = graph.edges()\r\n\r\n    this.initNodeLayoutProps(nodes, false)\r\n\r\n    // Add inertia and reset force\r\n    nodes.forEach(node => {\r\n      node.layoutProps.i.x = node.layoutProps.f.x\r\n      node.layoutProps.i.y = node.layoutProps.f.y\r\n      node.layoutProps.f.x *= this.inertia\r\n      node.layoutProps.f.y *= this.inertia\r\n    })\r\n\r\n    // Repulsion\r\n    if (this.adjustSizes) {\r\n      nodes.forEach(n1 => {\r\n        nodes.forEach(n2 => {\r\n          if (n1 !== n2) {\r\n            forceNodes(\r\n              n1,\r\n              n2,\r\n              this.repStr * (1 + graph.getDegree(n1)) * (1 + graph.getDegree(n2)),\r\n              false,\r\n              true\r\n            )\r\n          }\r\n        })\r\n      })\r\n    } else {\r\n      nodes.forEach(n1 => {\r\n        nodes.forEach(n2 => {\r\n          if (n1 !== n2) {\r\n            forceNodes(\r\n              n1,\r\n              n2,\r\n              this.repStr * (1 + graph.getDegree(n1)) * (1 + graph.getDegree(n2)),\r\n              false\r\n            )\r\n          }\r\n        })\r\n      })\r\n    }\r\n\r\n    // Attraction\r\n    if (this.adjustSizes) {\r\n      if (this.outAttrDistr) {\r\n        edges.forEach(edge => {\r\n          const source = edge.source\r\n          const target = edge.target\r\n          // TODO: Possibly add weights\r\n          forceNodes(source, target, this.attrStr / (1 + graph.getDegree(source)), true, true)\r\n        })\r\n      } else {\r\n        edges.forEach(edge => {\r\n          const source = edge.source\r\n          const target = edge.target\r\n          // TODO: Possibly add weights\r\n          forceNodes(source, target, this.attrStr, true, true)\r\n        })\r\n      }\r\n    } else {\r\n      if (this.outAttrDistr) {\r\n        edges.forEach(edge => {\r\n          const source = edge.source\r\n          const target = edge.target\r\n          // TODO: Possibly add weights\r\n          forceNodes(source, target, this.attrStr / (1 + graph.getDegree(source)), true)\r\n        })\r\n      } else {\r\n        edges.forEach(edge => {\r\n          const source = edge.source\r\n          const target = edge.target\r\n          // TODO: Possibly add weights\r\n          forceNodes(source, target, this.attrStr, true)\r\n        })\r\n      }\r\n    }\r\n\r\n    // Gravity\r\n    nodes.forEach(node => {\r\n      const nx = node.x\r\n      const ny = node.y\r\n      const d = 0.0001 + sumSqrt(nx, ny)\r\n      const gf = 0.0001 * this.gravity * d\r\n      assignForce(node, nx, ny, d, -gf)\r\n    })\r\n\r\n    // Speed\r\n    if (this.freezeBal) {\r\n      nodes.forEach(node => {\r\n        node.layoutProps.f.x *= this.speed * 10\r\n        node.layoutProps.f.y *= this.speed * 10\r\n      })\r\n    } else {\r\n      nodes.forEach(node => {\r\n        node.layoutProps.f.x *= this.speed\r\n        node.layoutProps.f.y *= this.speed\r\n      })\r\n    }\r\n\r\n    this.prevLimit = 0\r\n    // Apply forces\r\n    nodes.forEach(node => {\r\n      const layoutProps = node.layoutProps\r\n      const dist = 0.0001 + sumSqrt(layoutProps.f.x, layoutProps.f.y)\r\n      let ratio: number\r\n      if (this.freezeBal) {\r\n        if (!layoutProps.freeze) layoutProps.freeze = 0\r\n        layoutProps.freeze =\r\n          (this.freezeIner * layoutProps.freeze + (1 - this.freezeIner)) *\r\n          0.1 *\r\n          this.freezeStr *\r\n          Math.sqrt(sumSqrt(layoutProps.i.x - layoutProps.f.x, layoutProps.i.y - layoutProps.f.y))\r\n        ratio = Math.min(dist / (dist * (1 + layoutProps.freeze)), this.maxDispl / dist)\r\n      } else {\r\n        ratio = Math.min(1, this.maxDispl / dist)\r\n      }\r\n      layoutProps.f.x *= ratio / this.cooling\r\n      layoutProps.f.y *= ratio / this.cooling\r\n      this.prevLimit = Math.max(this.prevLimit, dist * ratio)\r\n      node.x += layoutProps.f.x\r\n      node.y += layoutProps.f.y\r\n    })\r\n  }\r\n\r\n  protected shouldContinue(graph: Graph) {\r\n    return this.prevLimit > this.minMovement\r\n  }\r\n}\r\n","import { ILayout } from '../classes/ILayout'\r\nimport Layout from '../classes/Layout'\r\nimport Graph from '../classes/Graph'\r\n\r\nexport default class FruchtermanReingold extends Layout implements ILayout {\r\n  public readonly incremental = true\r\n\r\n  // Constants\r\n  private SPEED_DIVISOR = 800\r\n  private AREA_MULTIPLICATOR = 10000\r\n\r\n  // Algorithm properties\r\n  protected area = 10000\r\n  protected speed = 10\r\n  protected gravity = 10\r\n  protected minMovement = 0.01\r\n\r\n  // Internal variables\r\n  private prevLimit: number\r\n\r\n  protected process(graph: Graph) {\r\n    const nodes = graph.nodes()\r\n    const edges = graph.edges()\r\n\r\n    this.initNodeLayoutProps(nodes)\r\n\r\n    const maxDistance = Math.sqrt(this.AREA_MULTIPLICATOR * this.area) / 10\r\n    const k = Math.sqrt((this.AREA_MULTIPLICATOR * this.area) / (1 + nodes.length))\r\n\r\n    // Repulsion\r\n    nodes.forEach(n1 => {\r\n      nodes.forEach(n2 => {\r\n        if (n1 !== n2) {\r\n          const xDist = n1.x - n2.x\r\n          const yDist = n1.y - n2.y\r\n          const dist = Math.sqrt(xDist * xDist + yDist * yDist)\r\n\r\n          if (dist > 0) {\r\n            const force = (k * k) / dist\r\n            n1.layoutProps.f.x += (xDist / dist) * force\r\n            n1.layoutProps.f.y += (yDist / dist) * force\r\n          }\r\n        }\r\n      })\r\n    })\r\n\r\n    // Attraction\r\n    edges.forEach(e => {\r\n      const nS = e.source\r\n      const nT = e.target\r\n\r\n      const xDist = nS.x - nT.x\r\n      const yDist = nS.y - nT.y\r\n      const dist = Math.sqrt(xDist * xDist + yDist * yDist)\r\n      const force = (dist * dist) / k\r\n\r\n      if (dist > 0) {\r\n        nS.layoutProps.f.x -= (xDist / dist) * force\r\n        nS.layoutProps.f.y -= (yDist / dist) * force\r\n        nT.layoutProps.f.x += (xDist / dist) * force\r\n        nT.layoutProps.f.y += (yDist / dist) * force\r\n      }\r\n    })\r\n\r\n    // Gravity\r\n    nodes.forEach(node => {\r\n      const d = Math.sqrt(node.x * node.x + node.y * node.y)\r\n      const gf = 0.01 * k * this.gravity * d\r\n      node.layoutProps.f.x -= (gf * node.x) / d\r\n      node.layoutProps.f.y -= (gf * node.y) / d\r\n    })\r\n\r\n    // Speed\r\n    nodes.forEach(node => {\r\n      const speedMultiplier = this.speed / this.SPEED_DIVISOR\r\n      node.layoutProps.f.x *= speedMultiplier\r\n      node.layoutProps.f.y *= speedMultiplier\r\n    })\r\n    this.prevLimit = 0\r\n\r\n    // Apply force to position\r\n    nodes.forEach(node => {\r\n      const xDist = node.layoutProps.f.x\r\n      const yDist = node.layoutProps.f.y\r\n      const dist = Math.sqrt(xDist * xDist + yDist * yDist)\r\n      // Consider adding node.isFixed()\r\n      if (dist > 0) {\r\n        const limitedDist = Math.min(maxDistance * (this.speed / this.SPEED_DIVISOR), dist)\r\n        this.prevLimit = Math.max(this.prevLimit, limitedDist)\r\n        node.x += (xDist / dist) * limitedDist\r\n        node.y += (yDist / dist) * limitedDist\r\n      }\r\n    })\r\n  }\r\n\r\n  protected init(graph: Graph) {\r\n    this.minMovement = 0.001 * graph.nodes().length\r\n  }\r\n\r\n  protected shouldContinue(graph: Graph) {\r\n    return this.prevLimit > this.minMovement\r\n  }\r\n}\r\n","import Layout from '../classes/Layout'\r\nimport { ILayout } from '../classes/ILayout'\r\nimport Graph from '../classes/Graph'\r\nimport { eigenPower } from './util'\r\n\r\nexport default class MDS extends Layout implements ILayout {\r\n  public incremental = false\r\n\r\n  protected scale: number = 1000\r\n\r\n  public process(graph: Graph) {\r\n    const nodes = graph.calcPaths()\r\n    const d: number[][] = []\r\n    let sum = 0\r\n    let count = 0\r\n\r\n    // Calculate distance^2 and sum of distances\r\n    nodes.forEach(n1 => {\r\n      const n1M: number[] = []\r\n      d.push(n1M)\r\n      nodes.forEach(n2 => {\r\n        const dist = n1.layoutProps.dist[n2.id]\r\n        const dist2 = dist * dist\r\n        n1M.push(dist2)\r\n        sum += dist2\r\n        count += 1\r\n      })\r\n    })\r\n\r\n    // Calculate mean of distance^2 and subtract from matrix\r\n    const mean = sum / d.length / d.length\r\n\r\n    // Calculate row averages and subtract from matrix\r\n    const averages = d.map(row => row.reduce((prev, col) => prev + col, 0) / row.length)\r\n    const d3 = d.map((row, i) => row.map((col, j) => col - averages[i] - averages[j] + mean))\r\n\r\n    // Calculate B matrix\r\n    const B = d3.map(row => row.map(col => col * (-1 / 2)))\r\n\r\n    // Get Eigenvector and 2 highest values\r\n    const { values, vectors } = eigenPower(B)\r\n    const maxEigen: number = Math.max(...values)\r\n    const maxEigenIndex = values.indexOf(maxEigen)\r\n    values[maxEigenIndex] = -Infinity\r\n    const max2Eigen: number = Math.max(...values)\r\n    const max2EigenIndex = values.indexOf(max2Eigen)\r\n    values[maxEigenIndex] = maxEigen\r\n    const maxEigenSqrt = Math.sqrt(maxEigen)\r\n    const max2EigenSqrt = Math.sqrt(max2Eigen)\r\n\r\n    // Calculate coordinates\r\n    // vectors[1][0] = vectors[0][1]\r\n    console.log('vectors', vectors)\r\n    console.log('values', values)\r\n    const n = values.length\r\n    this.scale = this.scale / Math.max(values[0], values[1])\r\n    nodes.forEach((node, index) => {\r\n      node.x = vectors[0][index] * values[0] * this.scale\r\n      node.y = vectors[1][index] * values[1] * this.scale\r\n      // node.x = vectors[maxEigenIndex][index] * maxEigenSqrt * this.scale\r\n      // node.y = vectors[max2EigenIndex][index] * max2EigenSqrt * this.scale\r\n      // if (maxEigenIndex >= index) node.x = vectors[maxEigenIndex][index] * maxEigenSqrt * this.scale\r\n      // else node.x = vectors[index][maxEigenIndex] * maxEigenSqrt * this.scale\r\n      // if (max2EigenIndex >= index) {\r\n      //   node.y = vectors[max2EigenIndex][index] * max2EigenSqrt * this.scale\r\n      // } else node.y = vectors[index][max2EigenIndex] * max2EigenSqrt * this.scale\r\n    })\r\n  }\r\n\r\n  public shouldContinue(graph: Graph): boolean {\r\n    return false\r\n  }\r\n}\r\n","import Layout from '../classes/Layout'\r\nimport { ILayout } from '../classes/ILayout'\r\nimport Graph, { Node } from '../classes/Graph'\r\nimport { sumSqrt } from './util'\r\n\r\ninterface QueueListObject {\r\n  node: Node\r\n  dist: number\r\n}\r\n\r\nexport default class ISOMv2 extends Layout implements ILayout {\r\n  public incremental: boolean = true\r\n\r\n  // Parameters\r\n  protected maxIterations: number = 2000\r\n  protected adaption: number = 0.8\r\n  protected radius: number = 3\r\n  protected cooling: number = 2\r\n  protected iterPerRadius = 70\r\n\r\n  protected bounds: number[] = [0, 0, 1000, 1000]\r\n\r\n  // Internal\r\n  protected t: number = 1\r\n  protected minRadius: number = 1\r\n  protected minAdaption = 0.15\r\n  protected currAdaption: number\r\n\r\n  public process(graph: Graph) {\r\n    const nodes = graph.nodes()\r\n    const edges = graph.edges()\r\n    this.t += 1\r\n\r\n    const tmp = {\r\n      x: this.bounds[0] + Math.random() * (this.bounds[2] - this.bounds[0]),\r\n      y: this.bounds[1] + Math.random() * (this.bounds[3] - this.bounds[1]),\r\n    }\r\n\r\n    let winner: Node\r\n    let dist: number = Infinity\r\n    nodes.forEach(node => {\r\n      const dx = tmp.x - node.x\r\n      const dy = tmp.y - node.y\r\n      const distSqr = dx * dx + dy * dy\r\n      if (distSqr < dist) {\r\n        dist = distSqr\r\n        winner = node\r\n      }\r\n    })\r\n\r\n    // relax positions\r\n    const queue: QueueListObject[] = [{ node: winner, dist: 1 }]\r\n    const visited = {\r\n      [winner.id]: true,\r\n    }\r\n    while (queue.length > 0) {\r\n      const { node, dist } = queue.pop()\r\n\r\n      const f = this.currAdaption / Math.pow(2, dist)\r\n\r\n      node.x -= f * (node.x - tmp.x)\r\n      node.y -= f * (node.y - tmp.y)\r\n\r\n      // Enqueue neighbours\r\n      if (dist < this.radius) {\r\n        edges.forEach(edge => {\r\n          let nb: Node | null = null\r\n          if (edge.source === node) nb = edge.target\r\n          else if (edge.target === node) nb = edge.source\r\n\r\n          if (nb && !visited[nb.id]) {\r\n            queue.push({ node: nb, dist: dist + 1 })\r\n            visited[nb.id] = true\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    const factor = Math.exp((-1 * this.cooling * this.t) / this.maxIterations)\r\n    this.currAdaption = Math.max(this.minAdaption, factor * this.adaption)\r\n    if (this.currAdaption === this.minAdaption) {\r\n      this.minRadius = 0\r\n    }\r\n    if (this.radius > this.minRadius && this.t % this.iterPerRadius === 0) {\r\n      this.radius -= 1\r\n    }\r\n  }\r\n\r\n  protected init(graph: Graph): void {\r\n    const nodes = graph.nodes()\r\n    this.maxIterations = 20 * nodes.length\r\n    this.radius = Math.ceil(Math.log(nodes.length) * 1.5)\r\n    this.iterPerRadius = Math.floor(this.maxIterations / 1.2 / this.radius)\r\n    const boundsEdgeSize = Math.sqrt(nodes.length) * 100\r\n    this.bounds = [-boundsEdgeSize / 2, -boundsEdgeSize / 2, boundsEdgeSize / 2, boundsEdgeSize / 2]\r\n    this.currAdaption = this.adaption\r\n  }\r\n\r\n  public shouldContinue(graph: Graph): boolean {\r\n    return this.t < this.maxIterations\r\n  }\r\n}\r\n"],"sourceRoot":""}