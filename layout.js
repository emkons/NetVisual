(window.webpackJsonp=window.webpackJsonp||[]).push([[1],[,,,,,,,,,,,,,function(t,s,i){"use strict";i.d(s,"a",function(){return o});var e=i(5);class o extends e.a{constructor(){super(...arguments),this.timePerIteration=3,this.running=!1,this.totalRuntime=0,this.initRuntime=0}start(t){const s=window.performance.now();this.init(t);const i=window.performance.now();return this.initRuntime=i-s,this.totalRuntime=i-s,this.running=!0,setTimeout(()=>{this.iterate(t)},0),new Promise(t=>{this.subscribe("done",t)})}iterate(t){const s=window.performance.now();let i=0;do{this.process(t),i=window.performance.now()}while(i-s<this.timePerIteration&&this.shouldContinue(t));this.totalRuntime+=i-s,this.dispatch("iteration",t),this.incremental&&this.running&&this.shouldContinue(t)?setTimeout(()=>{this.iterate(t)},0):(console.log(`Layout finished in ${this.totalRuntime}ms, init time: ${this.initRuntime}`),this.dispatch("done",t))}getInitRuntime(){return this.initRuntime}getTotalRuntime(){return this.totalRuntime}stop(){return this.running=!1,this.running}initNodeLayoutProps(t,s=!0){t.forEach(t=>{t.layoutProps||(t.layoutProps={f:{x:0,y:0},i:{x:0,y:0}}),s&&(t.layoutProps.f={x:0,y:0})})}init(t){this.initNodeLayoutProps(t.nodes())}}},function(t,s,i){"use strict";i.r(s),i.d(s,"default",function(){return r});var e=i(13),o=i(4);class r extends e.a{constructor(){super(...arguments),this.incremental=!0,this.diameter=6e3,this.sprConst=10,this.currPass=2,this.shouldStop=!1,this.mDi=0,this.mD=10}process(t){const s=t.nodes();t.edges();this.initNodeLayoutProps(s);const i=s[this.mDi];let e=this.mD,r=0;for(;e>.001&&r<10;){r+=1;const t=i.x,n=i.y;let a=0,h=0,c=0;s.forEach(s=>{if(s===i)return;const e=t-s.x,r=n-s.y,u=Object(o.d)(e,r)*(e*e+r*r),l=i.layoutProps.const[s.id],d=i.layoutProps.length[s.id];a+=l*(1-d*r*r/u),h+=l*d*e*r/u,c+=l*(1-d*e*e/u)});const u=i.layoutProps.delta.x,l=i.layoutProps.delta.y,d=(u*h-l*a)/(a*c-h*h),p=(h*l-c*u)/(a*c-h*h);i.x=t+p,i.y=n+d;const y=t+p,f=n+d;let m=0,P=0;s.forEach(s=>{if(s===i)return;const e=t-s.x,r=n-s.y,a=Object(o.d)(e,r),h=y-s.x,c=f-s.y,u=Object(o.d)(h,c),l=i.layoutProps.const[s.id],d=i.layoutProps.length[s.id],p=s.layoutProps.delta;p.x-=l*(e-d*e/a),p.y-=l*(r-d*r/a),p.x+=l*(h-d*h/u),p.y+=l*(c-d*c/u),m+=l*(h-d*h/u),P+=l*(c-d*c/u)});const x=i.layoutProps.delta;x.x=m,x.y=P,e=m*m+P*P,i.x=y,i.y=f}let n=0,a=0;s.forEach((t,s)=>{const i=t.layoutProps.delta.x,e=t.layoutProps.delta.y,o=i*i+e*e;o>n&&(n=o,a=s)}),this.mD=n,this.mDi=a}init(t){this.initNodeLayoutProps(t.nodes()),this.diameter=300*Math.sqrt(t.nodes().length);let s=0;const i=t.calcPaths();i.forEach(t=>{i.forEach(i=>{if(t===i)return;const e=Math.min(t.layoutProps.dist[i.id],i.layoutProps.dist[t.id]);s=Math.max(s,e),t.layoutProps.dist[i.id]=e,i.layoutProps.dist[t.id]=e})}),this.edgeLen=this.diameter/s,i.forEach(t=>{t.layoutProps.length={},t.layoutProps.const={},i.forEach(s=>{if(t===s)return;s.layoutProps.length||(s.layoutProps.length={}),s.layoutProps.const||(s.layoutProps.const={});const i=this.edgeLen*t.layoutProps.dist[s.id],e=this.sprConst/(i*i);t.layoutProps.length[s.id]=i,s.layoutProps.length[t.id]=i,t.layoutProps.const[s.id]=e,s.layoutProps.const[t.id]=e})});const e=i.length,r=2*Math.PI/e;let n=0;i.forEach(t=>{t.x=Math.sin(n)*this.diameter,t.y=Math.cos(n)*this.diameter,n+=r});let a=0,h=0;i.forEach((t,s)=>{let e=0,r=0;i.forEach(s=>{if(t===s)return;const i=t.x-s.x,n=t.y-s.y,a=Object(o.d)(i,n);e+=t.layoutProps.const[s.id]*(i-t.layoutProps.length[s.id]*i/a),r+=t.layoutProps.const[s.id]*(n-t.layoutProps.length[s.id]*n/a)});const n=e*e+r*r;n>a&&(a=n,h=s),t.layoutProps.delta={x:e,y:r}}),this.mD=a,this.mDi=h}shouldContinue(t){return this.mD>.001}}},function(t,s,i){"use strict";i.r(s),i.d(s,"default",function(){return r});var e=i(13),o=i(4);class r extends e.a{constructor(){super(...arguments),this.incremental=!0,this.inertia=.1,this.repStr=200,this.attrStr=1,this.maxDispl=100,this.freezeBal=!0,this.freezeStr=5,this.freezeIner=.1,this.gravity=1,this.speed=1,this.cooling=1,this.outAttrDistr=!0,this.adjustSizes=!1,this.minMovement=3}process(t){const s=t.nodes(),i=t.edges();this.initNodeLayoutProps(s,!1),s.forEach(t=>{t.layoutProps.i.x=t.layoutProps.f.x,t.layoutProps.i.y=t.layoutProps.f.y,t.layoutProps.f.x*=this.inertia,t.layoutProps.f.y*=this.inertia}),this.adjustSizes?s.forEach(i=>{s.forEach(s=>{i!==s&&Object(o.c)(i,s,this.repStr*(1+t.getDegree(i))*(1+t.getDegree(s)),!1,!0)})}):s.forEach(i=>{s.forEach(s=>{i!==s&&Object(o.c)(i,s,this.repStr*(1+t.getDegree(i))*(1+t.getDegree(s)),!1)})}),this.adjustSizes?this.outAttrDistr?i.forEach(s=>{const i=s.source,e=s.target;Object(o.c)(i,e,this.attrStr/(1+t.getDegree(i)),!0,!0)}):i.forEach(t=>{const s=t.source,i=t.target;Object(o.c)(s,i,this.attrStr,!0,!0)}):this.outAttrDistr?i.forEach(s=>{const i=s.source,e=s.target;Object(o.c)(i,e,this.attrStr/(1+t.getDegree(i)),!0)}):i.forEach(t=>{const s=t.source,i=t.target;Object(o.c)(s,i,this.attrStr,!0)}),s.forEach(t=>{const s=t.x,i=t.y,e=1e-4+Object(o.d)(s,i),r=1e-4*this.gravity*e;Object(o.a)(t,s,i,e,-r)}),this.freezeBal?s.forEach(t=>{t.layoutProps.f.x*=10*this.speed,t.layoutProps.f.y*=10*this.speed}):s.forEach(t=>{t.layoutProps.f.x*=this.speed,t.layoutProps.f.y*=this.speed}),this.prevLimit=0,s.forEach(t=>{const s=t.layoutProps,i=1e-4+Object(o.d)(s.f.x,s.f.y);let e;this.freezeBal?(s.freeze||(s.freeze=0),s.freeze=.1*(this.freezeIner*s.freeze+(1-this.freezeIner))*this.freezeStr*Math.sqrt(Object(o.d)(s.i.x-s.f.x,s.i.y-s.f.y)),e=Math.min(i/(i*(1+s.freeze)),this.maxDispl/i)):e=Math.min(1,this.maxDispl/i),s.f.x*=e/this.cooling,s.f.y*=e/this.cooling,this.prevLimit=Math.max(this.prevLimit,i*e),t.x+=s.f.x,t.y+=s.f.y})}shouldContinue(t){return this.prevLimit>this.minMovement}}},function(t,s,i){"use strict";i.r(s),i.d(s,"default",function(){return o});var e=i(13);class o extends e.a{constructor(){super(...arguments),this.incremental=!0,this.SPEED_DIVISOR=800,this.AREA_MULTIPLICATOR=1e4,this.area=1e4,this.speed=10,this.gravity=10,this.minMovement=.01}process(t){const s=t.nodes(),i=t.edges();this.initNodeLayoutProps(s);const e=Math.sqrt(this.AREA_MULTIPLICATOR*this.area)/10,o=Math.sqrt(this.AREA_MULTIPLICATOR*this.area/(1+s.length));s.forEach(t=>{s.forEach(s=>{if(t!==s){const i=t.x-s.x,e=t.y-s.y,r=Math.sqrt(i*i+e*e);if(r>0){const s=o*o/r;t.layoutProps.f.x+=i/r*s,t.layoutProps.f.y+=e/r*s}}})}),i.forEach(t=>{const s=t.source,i=t.target,e=s.x-i.x,r=s.y-i.y,n=Math.sqrt(e*e+r*r),a=n*n/o;n>0&&(s.layoutProps.f.x-=e/n*a,s.layoutProps.f.y-=r/n*a,i.layoutProps.f.x+=e/n*a,i.layoutProps.f.y+=r/n*a)}),s.forEach(t=>{const s=Math.sqrt(t.x*t.x+t.y*t.y),i=.01*o*this.gravity*s;t.layoutProps.f.x-=i*t.x/s,t.layoutProps.f.y-=i*t.y/s}),s.forEach(t=>{const s=this.speed/this.SPEED_DIVISOR;t.layoutProps.f.x*=s,t.layoutProps.f.y*=s}),this.prevLimit=0,s.forEach(t=>{const s=t.layoutProps.f.x,i=t.layoutProps.f.y,o=Math.sqrt(s*s+i*i);if(o>0){const r=Math.min(e*(this.speed/this.SPEED_DIVISOR),o);this.prevLimit=Math.max(this.prevLimit,r),t.x+=s/o*r,t.y+=i/o*r}})}init(t){this.minMovement=.001*t.nodes().length}shouldContinue(t){return this.prevLimit>this.minMovement}}},function(t,s,i){"use strict";i.r(s),i.d(s,"default",function(){return r});var e=i(13),o=i(4);class r extends e.a{constructor(){super(...arguments),this.incremental=!1,this.scale=1e3}process(t){const s=t.calcPaths(),i=[];let e=0,r=0;s.forEach(t=>{const o=[];i.push(o),s.forEach(s=>{const i=t.layoutProps.dist[s.id],n=i*i;o.push(n),e+=n,r+=1})});const n=e/i.length/i.length,a=i.map(t=>t.reduce((t,s)=>t+s,0)/t.length),h=i.map((t,s)=>t.map((t,i)=>t-a[s]-a[i]+n)).map(t=>t.map(t=>-.5*t)),{values:c,vectors:u}=Object(o.b)(h),l=Math.max(...c),d=c.indexOf(l);c[d]=-1/0;const p=Math.max(...c);c.indexOf(p);c[d]=l;Math.sqrt(l),Math.sqrt(p);console.log("vectors",u),console.log("values",c);c.length;this.scale=this.scale/Math.max(c[0],c[1]),s.forEach((t,s)=>{t.x=u[0][s]*c[0]*this.scale,t.y=u[1][s]*c[1]*this.scale})}shouldContinue(t){return!1}}},function(t,s,i){"use strict";i.r(s),i.d(s,"default",function(){return o});var e=i(13);class o extends e.a{constructor(){super(...arguments),this.incremental=!0,this.maxIterations=2e3,this.adaption=.8,this.radius=3,this.cooling=2,this.iterPerRadius=70,this.bounds=[0,0,1e3,1e3],this.t=1,this.minRadius=1,this.minAdaption=.15}process(t){const s=t.nodes(),i=t.edges();this.t+=1;const e=this.bounds[0]+Math.random()*(this.bounds[2]-this.bounds[0]),o=this.bounds[1]+Math.random()*(this.bounds[3]-this.bounds[1]);let r,n=1/0;s.forEach(t=>{const s=e-t.x,i=o-t.y,a=s*s+i*i;a<n&&(n=a,r=t)});const a=[{node:r,dist:1}],h={[r.id]:!0};for(;a.length>0;){const{node:t,dist:s}=a.pop(),r=this.currAdaption/Math.pow(2,s);t.x-=r*(t.x-e),t.y-=r*(t.y-o),s<this.radius&&i.forEach(i=>{let e=null;i.source===t?e=i.target:i.target===t&&(e=i.source),e&&!h[e.id]&&(a.push({node:e,dist:s+1}),h[e.id]=!0)})}const c=Math.exp(-1*this.cooling*this.t/this.maxIterations);this.currAdaption=Math.max(this.minAdaption,c*this.adaption),this.currAdaption===this.minAdaption&&(this.minRadius=0),this.radius>this.minRadius&&this.t%this.iterPerRadius==0&&(this.radius-=1)}init(t){const s=t.nodes();this.maxIterations=20*s.length,this.radius=Math.ceil(1.5*Math.log(s.length)),this.iterPerRadius=Math.floor(this.maxIterations/1.2/this.radius);const i=100*Math.sqrt(s.length);this.bounds=[-i/2,-i/2,i/2,i/2],this.currAdaption=this.adaption}shouldContinue(t){return this.t<this.maxIterations}}}]]);
//# sourceMappingURL=layout.js.map